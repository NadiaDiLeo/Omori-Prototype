<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interfaccia Interattiva Omori</title>
  <style>
    @font-face {
      font-family: 'OmoriFont';
      src: url('OMORI_GAME2.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    
    body {
      font-family: 'OmoriFont', sans-serif;
      margin: 0;
      padding: 0;
      background-image: url('images/background.png');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      color: white;
      text-align: center;
    }

    #selector-container {
      padding: 20px;
      background-color: rgba(0, 0, 0, 0.5);
    }

    #postSelector {
      font-family: 'OmoriFont', sans-serif;
      font-size: 1em;
      background: #000000;
      color: white;
      border: 2px solid #ffffff;
      padding: 5px;
      min-width: 400px;
      max-width: 80%;
    }

    #controls-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
      display: flex;
      gap: 15px;
    }

    .control-icon {
      width: 48px;
      height: 48px;
      cursor: pointer;
      border: 2px solid white;
      background-color: black;
      border-radius: 5px;
      padding: 5px;
    }
    
    #container {
      position: relative;
      width: 800px;
      height: 800px;
      background-color: transparent;
      border: none;
      cursor: pointer;
      overflow: visible;
      margin: 20px auto;
    }
    
    .big-omori {
      position: absolute;
      width: 400px;
      height: auto;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 5;
    }
    
    .bubble {
      position: absolute;
      background: #000000;
      border: 2px solid #ffffff;
      border-radius: 3px;
      padding: 15px;
      z-index: 10;
      color: white;
      box-shadow: 4px 4px 0px rgba(0, 0, 0, 0.5);
      text-align: left;
      width: 300px;
      height: 200px;
      font-size: 1.1em;
      overflow: hidden;
      box-sizing: border-box;
      overflow-wrap: break-word;
    }
    
    .comment-container {
      position: absolute;
      z-index: 10;
    }
    
    @keyframes slideFromRight {
      from { transform: translateX(100px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    @keyframes slideFromLeft {
      from { transform: translateX(-100px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    .slide-right {
      animation: slideFromRight 0.8s ease-out forwards;
    }
    
    .slide-left {
      animation: slideFromLeft 0.8s ease-out forwards;
    }
    
    .comment-img {
      position: absolute;
      width: 200px;
      height: 200px;
      border: none;
      border-radius: 0;
      object-fit: cover;
      z-index: 11;
    }
    
    .comment-container:not(.left) .comment-img { left: 0; }
    .comment-container.left .comment-img { right: 0; }
    
    .comment-bubble {
      position: absolute;
      background: #000000;
      border: 2px solid #ffffff;
      border-radius: 3px;
      padding: 15px;
      color: white;
      box-shadow: 4px 4px 0px rgba(0, 0, 0, 0.5);
      text-align: left;
      width: 250px;
      height: 150px;
      font-size: 1.1em;
      overflow: hidden;
      box-sizing: border-box;
      overflow-wrap: break-word;
    }
    
    .comment-container:not(.left) .comment-bubble { left: 210px; }
    .comment-container.left .comment-bubble { right: 210px; }
    
    .character-name {
      position: absolute;
      background: #000000;
      border: 2px solid #ffffff;
      padding: 2px 8px;
      font-size: 0.9em;
      color: white;
      text-transform: uppercase;
      font-weight: bold;
      z-index: 12;
    }

    .comment-container:not(.left) .character-name { left: 210px; top: -30px; }
    .comment-container.left .character-name { right: 210px; top: -30px; }
    
    .typing-text {
      display: inline;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <audio id="backgroundMusic" autoplay loop preload="auto">
    <source src="soundtrack.mp3" type="audio/mp3">
  </audio>

  <div id="controls-container">
    <img src="images/music.png" id="music-toggle" class="control-icon" alt="Toggle Music">
    <img src="images/text_to_speech_off.png" id="tts-toggle" class="control-icon" alt="Toggle Text to Speech">
  </div>
  
  <div id="selector-container">
    <label for="postSelector">Choose a Post:</label>
    <select id="postSelector">
      <option>Loading posts...</option>
    </select>
  </div>

  <div id="container">
    <img id="bigOmori" src="images/omoriknife.gif" alt="Omori Knife" class="big-omori">
  </div>

  <script>
    const backgroundMusic = document.getElementById('backgroundMusic');
    const musicToggle = document.getElementById('music-toggle');
    const ttsToggle = document.getElementById('tts-toggle');
    let isMusicPlaying = true;
    let isTtsEnabled = false;

    musicToggle.addEventListener('click', (e) => {
        e.stopPropagation();
        isMusicPlaying = !isMusicPlaying;
        if (isMusicPlaying) {
            backgroundMusic.play();
            musicToggle.src = 'images/music.png';
        } else {
            backgroundMusic.pause();
            musicToggle.src = 'images/no_music.png';
        }
    });

    ttsToggle.addEventListener('click', (e) => {
        e.stopPropagation();
        isTtsEnabled = !isTtsEnabled;
        ttsToggle.src = isTtsEnabled ? 'images/text_to_speech_on.png' : 'images/text_to_speech_off.png';
        if (!isTtsEnabled) window.speechSynthesis.cancel();
    });
    
    backgroundMusic.loop = true;
    window.addEventListener('load', () => { 
        backgroundMusic.play().catch(e => {
            isMusicPlaying = false;
            musicToggle.src = 'images/no_music.png';
            console.log("Autoplay prevented.");
        }); 
    });
    
    const POST_CHARS_PER_PAGE = 450;
    const COMMENT_CHARS_PER_PAGE = 250; 
    const characterNames = ["KEL", "HERO", "MARI", "KEL", "AUBREY", "BASIL"];
    const commentPositions = [
      { top: "10%", left: "50%" }, { top: "40%", left: "69%" }, { top: "70%", left: "50%" },
      { top: "70%", left: "30%" }, { top: "40%", left: "23%" }, { top: "10%", left: "30%" }
    ];
    const commentGifs = [
      "kelbackflip.gif", "herogun.gif", "mari2.gif",
      "kelbroken.gif", "aubrey.gif", "basil.gif"
    ];
    
    let allPosts = [];
    let currentPostIndex = 0;
    let currentCommentIndex = 0;
    let currentPostPage = 0;
    let currentCommentPage = 0;
    let state = "ready";
    let typingInProgress = false;
    
    const container = document.getElementById("container");
    const postSelector = document.getElementById("postSelector");
    
    document.addEventListener('DOMContentLoaded', () => {
      fetch('omori_posts.json')
        .then(response => response.json())
        .then(data => {
          allPosts = data.map(post => {
            const cleanText = (text) => text.replace(/\n{2,}/g, '\n').trim();
            const postContent = cleanText(`${post.title}\n\n${post.selftext || ''}`);
            const comments = post.comments.map(comment => cleanText(comment.body));
            return { post: postContent, comments: comments };
          });
          populatePostSelector();
        })
        .catch(error => console.error('Error loading JSON:', error));
    });

    function populatePostSelector() {
      postSelector.innerHTML = '';
      allPosts.forEach((postData, index) => {
        const option = document.createElement('option');
        option.value = index;
        const title = postData.post.split('\n')[0];
        option.textContent = title.length > 80 ? title.substring(0, 80) + '...' : title;
        postSelector.appendChild(option);
      });
    }

    postSelector.addEventListener('change', (event) => {
      currentPostIndex = parseInt(event.target.value, 10);
      resetForNewPost();
    });
    
    function speakText(text) {
        if (!isTtsEnabled) return;
        window.speechSynthesis.cancel();
        const textToSpeak = text.replace("... (click to continue)", "");
        const utterance = new SpeechSynthesisUtterance(textToSpeak);
        utterance.lang = 'en-US';
        window.speechSynthesis.speak(utterance);
    }
    
    function typeText(element, text, index = 0, callback) {
      if (index < text.length) {
        typingInProgress = true;
        element.textContent = text.substring(0, index + 1);
        setTimeout(() => typeText(element, text, index + 1, callback), 10);
      } else {
        typingInProgress = false;
        if (callback) callback();
      }
    }
    
    function showPost() {
      // --- FIXED: Remove previous post elements explicitly ---
      const existingBubble = document.querySelector('.bubble');
      if (existingBubble) container.removeChild(existingBubble);
      const existingName = document.querySelector('.main-post-name');
      if (existingName) container.removeChild(existingName);

      const currentPost = allPosts[currentPostIndex];
      const start = currentPostPage * POST_CHARS_PER_PAGE;
      let textToShow = currentPost.post.substring(start, start + POST_CHARS_PER_PAGE);
      if (start + POST_CHARS_PER_PAGE < currentPost.post.length) textToShow += "... (click to continue)";

      speakText(textToShow);

      // Create and position the text bubble
      const postBubbleElement = document.createElement("div");
      postBubbleElement.classList.add("bubble");
      postBubbleElement.style.top = "calc(30% - 120px)";
      postBubbleElement.style.left = "50%";
      postBubbleElement.style.transform = "translateX(-50%)";
      container.appendChild(postBubbleElement);

      // --- FIXED: Create and position the name tag as a SIBLING ---
      const nameLabel = document.createElement("div");
      nameLabel.classList.add("character-name", "main-post-name"); // Added class for easy removal
      nameLabel.textContent = "OMORI";
      nameLabel.style.position = 'absolute';
      nameLabel.style.top = 'calc(30% - 150px)'; // 30px above the bubble's top
      nameLabel.style.left = 'calc(50% - 150px)'; // Aligned with bubble's left edge
      container.appendChild(nameLabel);
      
      const textElement = document.createElement("div");
      textElement.classList.add("typing-text");
      postBubbleElement.appendChild(textElement); // Text still goes inside the bubble
      
      typeText(textElement, textToShow);
    }
    
    function addComment() {
      const currentPost = allPosts[currentPostIndex];
      const commentText = currentPost.comments[currentCommentIndex];
      const start = currentCommentPage * COMMENT_CHARS_PER_PAGE;
      let textToShow = commentText.substring(start, start + COMMENT_CHARS_PER_PAGE);
      if (start + COMMENT_CHARS_PER_PAGE < commentText.length) textToShow += "... (click to continue)";

      speakText(textToShow);

      const positionIndex = currentCommentIndex % commentPositions.length;
      const existingCommentContainer = document.querySelector(`.comment-container[data-position-index='${positionIndex}']`);
      if (existingCommentContainer) container.removeChild(existingCommentContainer);

      const commentContainer = document.createElement("div");
      commentContainer.classList.add("comment-container");
      commentContainer.dataset.positionIndex = positionIndex;

      if (positionIndex >= 3) commentContainer.classList.add("left", "slide-left");
      else commentContainer.classList.add("slide-right");
    
      const pos = commentPositions[positionIndex];
      commentContainer.style.top = pos.top;
      commentContainer.style.left = pos.left;
      
      const commentImg = document.createElement("img");
      const gifIndex = currentCommentIndex % commentGifs.length;
      commentImg.src = "images/" + commentGifs[gifIndex];
      commentImg.alt = "Comment Character";
      commentImg.classList.add("comment-img");
    
      const commentBubble = document.createElement("div");
      commentBubble.classList.add("comment-bubble");
      
      const textElement = document.createElement("div");
      textElement.classList.add("typing-text");
      commentBubble.appendChild(textElement);

      const nameLabel = document.createElement("div");
      nameLabel.classList.add("character-name");
      nameLabel.textContent = characterNames[gifIndex];
      
      commentContainer.appendChild(commentImg);
      commentContainer.appendChild(commentBubble);
      commentContainer.appendChild(nameLabel);
      container.appendChild(commentContainer);
      
      typeText(textElement, textToShow);
    }
    
    function resetContainer() {
      const children = Array.from(container.children);
      children.forEach(child => { if (child.id !== "bigOmori") container.removeChild(child); });
      window.speechSynthesis.cancel();
    }

    function resetForNewPost() {
        resetContainer();
        state = 'ready';
        currentPostPage = 0;
        currentCommentIndex = 0;
        currentCommentPage = 0;
    }
    
    container.addEventListener("click", function(){
      if (typingInProgress || allPosts.length === 0) return;
      
      const currentPostData = allPosts[currentPostIndex];

      if (state === "ready") {
        currentPostPage = 0;
        showPost();
        state = "postInProgress";
      } else if (state === "postInProgress") {
        const hasMorePostText = (currentPostPage + 1) * POST_CHARS_PER_PAGE < currentPostData.post.length;
        if (hasMorePostText) {
          currentPostPage++;
          showPost();
        } else {
          resetContainer();
          if (currentPostData.comments.length > 0) {
            currentCommentIndex = 0;
            currentCommentPage = 0;
            addComment();
            state = "commentInProgress";
          } else {
            state = "ready";
          }
        }
      } else if (state === "commentInProgress") {
        const currentCommentText = currentPostData.comments[currentCommentIndex];
        const hasMoreCommentText = (currentCommentPage + 1) * COMMENT_CHARS_PER_PAGE < currentCommentText.length;
        if (hasMoreCommentText) {
          currentCommentPage++;
          addComment();
        } else {
          currentCommentIndex++;
          currentCommentPage = 0;
          if (currentCommentIndex < currentPostData.comments.length) {
            if (currentCommentIndex > 0 && currentCommentIndex % 6 === 0) resetContainer();
            addComment();
          } else {
            resetForNewPost();
          }
        }
      }
    });
  </script>
</body>
</html>
