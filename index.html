<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1"
  />
  <title>Interfaccia Interattiva Omori</title>
  <style>
    :root{
      --bg: #0b0c10;
      --panel: #11131b;
      --muted: #9aa3b2;
      --text: #e9edf5;
      --accent: #9aa7ff;
      --accent-2: #ffd59a;
      --ring: #c4ccff;
      --ring-dim: #8089c4;
      --shadow: 0 12px 30px rgba(0,0,0,.45);
      --disc-size: min(420px, 72vw);
      --orbit-size: min(160px, 34vw);
      --orbit-radius: 38vmin; /* adaptive */
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: #0b0c10; color: var(--text); font: 14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial,"Apple Color Emoji","Segoe UI Emoji"; }
    body {
      background:
        radial-gradient(1200px 800px at 70% -10%, #182033 0%, #0b0c10 65%),
        radial-gradient(900px 600px at 0% 110%, rgba(120,120,255,.08), transparent 70%);
    }
    header {
      padding: 16px;
      display: grid;
      gap: 10px;
      border-bottom: 1px solid rgba(255,255,255,.06);
      background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0));
    }
    header h1 { margin: 0; font-size: 20px; font-weight: 650; letter-spacing: .2px; }
    header .sub { color: var(--muted); font-size: 12.5px; }
    .toolbar {
      display: grid; grid-template-columns: 1fr auto auto auto auto; gap: 8px; align-items: center;
    }
    .search-wrap { position: relative; }
    .search-input {
      width: 100%; padding: 10px 12px; border-radius: 10px; background: var(--panel); color: var(--text);
      border: 1px solid rgba(255,255,255,.07); outline: none; transition: border .15s ease, box-shadow .15s ease;
    }
    .search-input:focus { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(154,167,255,.18); }
    .suggestions {
      position: absolute; top: calc(100% + 6px); left: 0; right: 0; background: var(--panel); border: 1px solid rgba(255,255,255,.08);
      border-radius: 10px; overflow: hidden; box-shadow: var(--shadow); z-index: 20; display: none; max-height: 46vh; overflow-y: auto;
    }
    .suggestions.visible { display: block; }
    .suggestions button {
      display: block; width: 100%; text-align: left; padding: 10px 12px; background: transparent; border: 0; color: var(--text); cursor: pointer;
      border-bottom: 1px solid rgba(255,255,255,.05);
    }
    .suggestions button:last-child { border-bottom: 0; }
    .suggestions button:hover,.suggestions button:focus { background: #1a2034; }

    .btn {
      padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,.08); background: var(--panel); color: var(--text);
      cursor: pointer; transition: transform .05s ease, background .15s ease, border-color .15s ease; white-space: nowrap;
    }
    .btn:hover { background: #161a2a; }
    .btn:active { transform: translateY(1px); }
    .btn.primary { background: linear-gradient(180deg, #2c325c, #24294b); border-color: #2f3461; }
    .btn.accent { background: linear-gradient(180deg, #3a406d, #2f365f); border-color: #3a4070; }

    .status { display: flex; gap: 10px; align-items: center; color: var(--muted); font-size: 12.5px; }

    .container { padding: 14px; display: grid; gap: 14px; }
    .viz {
      position: relative; border: 1px solid rgba(255,255,255,.06); background: linear-gradient(180deg, #0d111b, #0b0d16);
      border-radius: 16px; min-height: 64vh; height: 70vh; overflow: hidden;
    }

    /* Central post media disc */
    .post-disc {
      position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); width: var(--disc-size); height: var(--disc-size);
      border-radius: 999px; overflow: hidden; box-shadow: var(--shadow);
      border: 6px solid var(--ring);
      outline: 2px dashed var(--ring-dim);
      outline-offset: 6px;
      background: #0f1322;
      display: grid; place-items: center;
    }
    .post-disc img, .post-disc video {
      width: 100%; height: 100%; object-fit: cover; display: block;
    }

    /* Orbiting comment media discs */
    .comments-layer { position: absolute; inset: 0; pointer-events: none; }
    .comment-disc {
      position: absolute; transform: translate(-50%,-50%) scale(.98);
      width: var(--orbit-size); height: var(--orbit-size); border-radius: 999px; overflow: hidden;
      border: 4px solid var(--ring); box-shadow: var(--shadow);
      background: #0f1322; opacity: 0; transition: opacity .2s ease, transform .2s ease;
      pointer-events: auto; /* clickable */
    }
    .comment-disc.visible { opacity: 1; transform: translate(-50%,-50%) scale(1.0) rotate(var(--tilt, 0deg)); }
    .comment-disc img, .comment-disc video { width: 100%; height: 100%; object-fit: cover; display: block; }
    .comment-badge {
      position: absolute; right: 6px; bottom: 6px; background: rgba(13,17,27,.72);
      backdrop-filter: blur(4px); border: 1px solid rgba(255,255,255,.15); color: #eaf0ff; font-size: 11.5px;
      border-radius: 999px; padding: 2px 8px;
    }

    /* Info card for post meta */
    .post-info {
      position: absolute; left: 50%; top: calc(50% + calc(var(--disc-size) / 2) + 16px);
      transform: translateX(-50%);
      background: rgba(13,17,27,.78); backdrop-filter: blur(6px); border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px; padding: 10px 12px; max-width: min(760px, 92vw);
      color: var(--text); box-shadow: var(--shadow);
    }
    .post-title { margin: 0 0 6px 0; font-size: 16px; line-height: 1.25; }
    .post-title a { color: var(--accent-2); text-decoration: none; border-bottom: 1px dashed rgba(255,255,255,.25); }
    .post-meta {
      display: flex; gap: 10px; flex-wrap: wrap; color: var(--muted); font-size: 12.5px;
    }
    .pill {
      display: inline-flex; align-items: center; gap: 6px; padding: 2px 8px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,.16); background: rgba(255,255,255,.06); color: var(--muted); font-size: 12px;
    }

    .controls { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; }
    .hint { text-align: center; color: var(--muted); font-size: 12.5px; }

    @media (max-width: 720px) {
      .toolbar { grid-template-columns: 1fr 1fr 1fr; }
      .toolbar .btn:nth-child(4) { display: none; } /* hide Prev on small to reduce clutter */
      .toolbar .btn:nth-child(5) { display: none; } /* hide Next */
      :root { --disc-size: min(360px, 82vw); --orbit-size: min(132px, 38vw); --orbit-radius: 42vmin; }
    }
    @media (max-height: 700px) {
      :root { --disc-size: min(360px, 54vh); --orbit-radius: 32vmin; }
    }
    @media (prefers-reduced-motion: reduce) {
      .comment-disc, .post-disc { transition: none; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Interfaccia Interattiva Omori</h1>
    <div class="sub">Explore r/OMORI posts with a central image/GIF and up to six orbiting comment images. Click to cycle.</div>

    <div class="toolbar">
      <div class="search-wrap">
        <input id="search" class="search-input" type="search" placeholder="Search by title, id, or authorâ€¦" autocomplete="off" />
        <div id="suggestions" class="suggestions" role="listbox" aria-label="Post suggestions"></div>
      </div>
      <button id="goBtn" class="btn primary">Go</button>
      <button id="randomBtn" class="btn accent">Random</button>
      <button id="prevBtn" class="btn">Prev</button>
      <button id="nextBtn" class="btn">Next</button>
    </div>

    <div class="status" id="status">Loading datasetâ€¦</div>
  </header>

  <main class="container">
    <section id="viz" class="viz" aria-live="polite" aria-label="Post and comments visualization">
      <div id="postDisc" class="post-disc" role="img" aria-label="Post media"></div>

      <div id="commentsLayer" class="comments-layer" aria-label="Orbiting comments layer"></div>

      <article id="postInfo" class="post-info" role="note" aria-label="Post details">
        <h2 id="postTitle" class="post-title">Loadingâ€¦</h2>
        <div id="postMeta" class="post-meta"></div>
      </article>
    </section>

    <div class="controls">
      <button id="nextCommentBtn" class="btn primary">Next Comment</button>
      <button id="clearCommentsBtn" class="btn">Clear</button>
      <button id="fillSixBtn" class="btn">Fill to 6</button>
    </div>
    <div class="hint">
      Tip: Click the visualization area or press Space/Enter to show the next comment. Up to six are shown at once; additional comments cycle in.
    </div>
  </main>

  <script>
    // Config
    const DATA_URL = 'omori_posts.json';

    // State
    let POSTS = [];
    let currentIndex = 0;
    let currentCommentsFlat = [];
    let commentPointer = 0;
    let replaceCounter = 0;
    const MAX_SLOTS = 6;
    const slotMap = new Map(); // slotIndex -> { el, commentIndex }

    // Elements
    const statusEl = document.getElementById('status');
    const vizEl = document.getElementById('viz');
    const postDiscEl = document.getElementById('postDisc');
    const postInfoEl = document.getElementById('postInfo');
    const postTitleEl = document.getElementById('postTitle');
    const postMetaEl = document.getElementById('postMeta');
    const commentsLayer = document.getElementById('commentsLayer');

    const searchInput = document.getElementById('search');
    const suggestionsEl = document.getElementById('suggestions');
    const goBtn = document.getElementById('goBtn');
    const randomBtn = document.getElementById('randomBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');

    const nextCommentBtn = document.getElementById('nextCommentBtn');
    const clearCommentsBtn = document.getElementById('clearCommentsBtn');
    const fillSixBtn = document.getElementById('fillSixBtn');

    // Utilities
    function fmtDate(post) {
      if (post.created_date) return post.created_date;
      if (post.created_utc) {
        const d = new Date(post.created_utc * 1000);
        return d.toISOString().replace('T', ' ').slice(0, 16);
      }
      return '';
    }

    function looksLikeImageURL(url) {
      if (!url) return false;
      const u = url.toLowerCase();
      if (/\.(png|jpe?g|gif|webp|bmp|avif)(\?|#|$)/i.test(u)) return true;
      // Reddit preview links often use ?format=...
      if (/[?&](format)=(png|jpg|jpeg|gif|webp)/i.test(u)) return true;
      return false;
    }

    function looksLikeVideoURL(url) {
      if (!url) return false;
      return /\.(mp4|webm|ogg)(\?|#|$)/i.test(url.toLowerCase());
    }

    function firstURLInText(text) {
      if (!text) return null;
      const m = text.match(/https?:\/\/[^\s)]+/i);
      return m ? m[0] : null;
    }

    function escapeForSVG(str) {
      return (str || '').replace(/&/g, '&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
    }

    function svgPlaceholder(label = 'No media') {
      const text = escapeForSVG(label).slice(0, 60);
      const svg =
        `<svg xmlns='http://www.w3.org/2000/svg' width='600' height='600'>
          <defs>
            <linearGradient id='g' x1='0' y1='0' x2='1' y2='1'>
              <stop offset='0%' stop-color='#1b2240'/>
              <stop offset='100%' stop-color='#0d1226'/>
            </linearGradient>
          </defs>
          <rect width='100%' height='100%' fill='url(#g)'/>
          <g fill='#9aa7ff' opacity='0.15'>
            <circle cx='300' cy='300' r='260'/>
            <circle cx='300' cy='300' r='220'/>
            <circle cx='300' cy='300' r='180'/>
          </g>
          <text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle'
                font-family='system-ui,Segoe UI,Roboto' font-size='28' fill='#e6e9ef' opacity='0.9'>
            ${text}
          </text>
        </svg>`;
      return 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg);
    }

    function setDiscMedia(container, url, altLabel = '') {
      container.innerHTML = '';
      if (looksLikeVideoURL(url)) {
        const v = document.createElement('video');
        v.src = url;
        v.autoplay = true;
        v.loop = true;
        v.muted = true;
        v.playsInline = true;
        v.setAttribute('aria-label', altLabel || 'Video');
        container.appendChild(v);
      } else {
        const img = document.createElement('img');
        img.src = url;
        img.alt = altLabel || 'Image';
        img.referrerPolicy = 'no-referrer';
        container.appendChild(img);
      }
    }

    function setDiscPlaceholder(container, label) {
      container.innerHTML = '';
      const img = document.createElement('img');
      img.src = svgPlaceholder(label);
      img.alt = label || 'Placeholder';
      container.appendChild(img);
    }

    function mediaFromPost(p) {
      // Prefer direct media URL on the post
      if (p && typeof p.url === 'string') {
        if (looksLikeImageURL(p.url) || looksLikeVideoURL(p.url)) return p.url;
      }
      // Try to find media in selftext
      const link = firstURLInText(p?.selftext || '');
      if (looksLikeImageURL(link) || looksLikeVideoURL(link)) return link;
      return null;
    }

    function mediaFromComment(c) {
      // Grab first URL in body that looks like image/video
      const link = firstURLInText(c?.body || '');
      if (looksLikeImageURL(link) || looksLikeVideoURL(link)) return link;
      return null;
    }

    function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }

    // Flatten comments and subcomments into one array
    function flattenComments(raw) {
      const out = [];
      const seen = new Set();

      function pushUnique(c) {
        if (!c || typeof c !== 'object') return;
        const id = c.id || Math.random().toString(36).slice(2);
        if (seen.has(id)) return;
        seen.add(id);
        out.push({ ...c, _id: id });
      }

      function walkList(list) {
        if (!Array.isArray(list)) return;
        for (const c of list) {
          pushUnique(c);
          const children = c.replies || c.children || c.comments || c.subcomments || c.reply || [];
          if (Array.isArray(children)) walkList(children);
        }
      }
      walkList(raw);

      const hasTime = out.every(c => typeof c.created_utc === 'number');
      if (hasTime) out.sort((a,b) => a.created_utc - b.created_utc);
      return out;
    }

    function computePosition(slotIndex) {
      // 6 evenly spaced positions around center
      const rect = vizEl.getBoundingClientRect();
      const cx = rect.width / 2;
      const cy = rect.height / 2;
      const r = Math.min(rect.width, rect.height) * 0.36; // radius
      const angle = (Math.PI * 2 * (slotIndex / MAX_SLOTS)) - Math.PI / 2;
      const x = cx + r * Math.cos(angle);
      const y = cy + r * Math.sin(angle);
      return { x, y, angle };
    }

    function clearAllComments() {
      slotMap.forEach(v => v.el.remove());
      slotMap.clear();
      replaceCounter = 0;
    }

    function renderCommentInSlot(slotIndex, comment, commentIndex) {
      let slot = slotMap.get(slotIndex);
      let el;
      if (!slot) {
        el = document.createElement('div');
        el.className = 'comment-disc';
        el.setAttribute('role', 'img');
        el.setAttribute('aria-label', 'Comment media');
        el.tabIndex = 0;
        commentsLayer.appendChild(el);
        slot = { el, commentIndex: -1 };
        slotMap.set(slotIndex, slot);
      } else {
        el = slot.el;
      }
      slot.commentIndex = commentIndex;

      const { x, y, angle } = computePosition(slotIndex);
      el.style.left = x + 'px';
      el.style.top = y + 'px';
      // Subtle tilt for a "collage" feel (varies per slot)
      const baseTilt = (-8 + (slotIndex * 3)) + 'deg';
      el.style.setProperty('--tilt', baseTilt);

      // Set media
      const mediaUrl = mediaFromComment(comment);
      const label = `u/${comment.author || '[deleted]'} â€” â–²${comment.score ?? 0}`;
      if (mediaUrl) {
        setDiscMedia(el, mediaUrl, label);
        el.dataset.linkHref = mediaUrl;
      } else {
        setDiscPlaceholder(el, (comment.body || 'No media').slice(0, 40));
        el.dataset.linkHref = '';
      }

      // Badge (author/score)
      const badge = document.createElement('div');
      badge.className = 'comment-badge';
      badge.textContent = `${comment.author || '[deleted]'} â€¢ â–²${comment.score ?? 0}`;
      el.appendChild(badge);

      // Tooltip via title attribute (full first line of comment)
      el.title = (comment.body || '').slice(0, 140);

      // Click to open media if present
      el.onclick = (e) => {
        const href = el.dataset.linkHref;
        if (href) window.open(href, '_blank', 'noopener');
      };

      requestAnimationFrame(() => {
        el.classList.add('visible');
      });
    }

    function nextComment() {
      if (!currentCommentsFlat.length) return;
      const visibleCount = slotMap.size;
      const slotIndex = visibleCount < MAX_SLOTS ? visibleCount : (replaceCounter % MAX_SLOTS);
      const comment = currentCommentsFlat[commentPointer];
      renderCommentInSlot(slotIndex, comment, commentPointer);
      commentPointer = (commentPointer + 1) % currentCommentsFlat.length;
      if (visibleCount >= MAX_SLOTS) replaceCounter++;
    }

    function fillToSix() {
      const needed = Math.max(0, MAX_SLOTS - slotMap.size);
      for (let i = 0; i < needed; i++) nextComment();
    }

    function renderPostInfo(p) {
      // Title (link to Reddit)
      postTitleEl.innerHTML = '';
      const tlink = document.createElement('a');
      tlink.href = p.permalink ? `https://www.reddit.com${p.permalink}` : '#';
      tlink.target = '_blank';
      tlink.rel = 'noopener noreferrer';
      tlink.textContent = p.title || '(untitled)';
      postTitleEl.appendChild(tlink);

      // Meta pills
      postMetaEl.innerHTML = '';
      const pills = [];
      const addPill = (text) => {
        const s = document.createElement('span');
        s.className = 'pill';
        s.textContent = text;
        pills.push(s);
      };
      addPill(p.author ? `u/${p.author}` : 'u/[deleted]');
      const dateStr = fmtDate(p);
      if (dateStr) addPill(dateStr);
      if (typeof p.score === 'number') addPill(`â–² ${p.score}`);
      if (typeof p.num_comments === 'number') addPill(`ðŸ’¬ ${p.num_comments}`);
      if (typeof p.upvote_ratio === 'number') addPill(`â¬†ï¸Ž ${Math.round(p.upvote_ratio * 100)}%`);
      if (p.link_flair_text) addPill(`Flair: ${p.link_flair_text}`);
      for (const x of pills) postMetaEl.appendChild(x);
    }

    function renderPostMedia(p) {
      const m = mediaFromPost(p);
      if (m) {
        setDiscMedia(postDiscEl, m, p.title || 'Post media');
      } else {
        // Fallback: generate placeholder with title
        setDiscPlaceholder(postDiscEl, (p.title || 'Post').slice(0, 60));
      }
    }

    function goToIndex(idx) {
      if (!POSTS.length) return;
      currentIndex = ((idx % POSTS.length) + POSTS.length) % POSTS.length;
      const post = POSTS[currentIndex];

      clearAllComments();
      commentPointer = 0;
      replaceCounter = 0;

      currentCommentsFlat = flattenComments(Array.isArray(post.comments) ? post.comments : []);

      renderPostMedia(post);
      renderPostInfo(post);

      const label = `Post ${currentIndex + 1}/${POSTS.length} â€” id: ${post.id}`;
      statusEl.textContent = `${label} â€¢ ${currentCommentsFlat.length} comments (flattened)`;

      const url = new URL(window.location.href);
      url.searchParams.set('id', post.id || '');
      history.replaceState(null, '', url.toString());
    }

    function findIndexById(id) {
      return POSTS.findIndex(p => (p.id || '').toLowerCase() === String(id || '').toLowerCase());
    }

    function buildSuggestions(query) {
      suggestionsEl.innerHTML = '';
      if (!query || query.trim().length < 2) {
        suggestionsEl.classList.remove('visible'); return;
      }
      const q = query.trim().toLowerCase();
      const items = POSTS.map((p, i) => {
        const id = (p.id || '').toLowerCase();
        const title = (p.title || '').toLowerCase();
        const author = (p.author || '').toLowerCase();
        let score = 0;
        if (id === q) score += 100;
        if (id.startsWith(q)) score += 60;
        if (title.includes(q)) score += 40;
        if (author.includes(q)) score += 20;
        return { i, p, score };
      }).filter(x => x.score > 0)
        .sort((a,b) => b.score - a.score)
        .slice(0, 12);
      if (!items.length) { suggestionsEl.classList.remove('visible'); return; }
      for (const {i, p} of items) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = `${p.id || 'no-id'} â€” ${p.title || '(untitled)'} (u/${p.author || '[deleted]'})`;
        btn.addEventListener('click', () => {
          goToIndex(i);
          suggestionsEl.classList.remove('visible');
          searchInput.blur();
        });
        suggestionsEl.appendChild(btn);
      }
      suggestionsEl.classList.add('visible');
    }

    function handleGo() {
      const q = searchInput.value.trim();
      if (!q) return;
      const byId = findIndexById(q);
      if (byId !== -1) {
        goToIndex(byId);
        suggestionsEl.classList.remove('visible');
        return;
      }
      const first = suggestionsEl.querySelector('button');
      if (first) { first.click(); return; }
      const idx = POSTS.findIndex(p => (p.title || '').toLowerCase().includes(q.toLowerCase()));
      if (idx !== -1) goToIndex(idx);
      suggestionsEl.classList.remove('visible');
    }

    // Events
    searchInput.addEventListener('input', () => buildSuggestions(searchInput.value));
    searchInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); handleGo(); }
      else if (e.key === 'Escape') { suggestionsEl.classList.remove('visible'); }
    });
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.search-wrap')) suggestionsEl.classList.remove('visible');
    });

    goBtn.addEventListener('click', handleGo);
    randomBtn.addEventListener('click', () => {
      if (!POSTS.length) return;
      const idx = Math.floor(Math.random() * POSTS.length);
      goToIndex(idx);
    });
    prevBtn.addEventListener('click', () => goToIndex(currentIndex - 1));
    nextBtn.addEventListener('click', () => goToIndex(currentIndex + 1));

    nextCommentBtn.addEventListener('click', nextComment);
    clearCommentsBtn.addEventListener('click', clearAllComments);
    fillSixBtn.addEventListener('click', () => {
      fillToSix();
      // If there are more than 6, prepare rotation to start replacing
      if (currentCommentsFlat.length > MAX_SLOTS && replaceCounter === 0) replaceCounter = 0;
    });

    // Clicking the viz area shows next comment (but ignore clicks on discs)
    vizEl.addEventListener('click', (e) => {
      if (e.target.closest('.comment-disc')) return;
      if (e.target.closest('.post-disc')) return;
      nextComment();
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.target === searchInput) return;
      if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); nextComment(); }
      else if (e.key === 'ArrowRight') { goToIndex(currentIndex + 1); }
      else if (e.key === 'ArrowLeft') { goToIndex(currentIndex - 1); }
      else if (e.key.toLowerCase() === 'c') { clearAllComments(); }
      else if (e.key.toLowerCase() === 'f') { fillToSix(); }
    });

    // Reposition discs on resize
    window.addEventListener('resize', () => {
      for (const [slotIndex, { el }] of slotMap.entries()) {
        const { x, y } = computePosition(slotIndex);
        el.style.left = x + 'px';
        el.style.top = y + 'px';
      }
    });

    async function loadData() {
      try {
        const res = await fetch(DATA_URL, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        if (!Array.isArray(data)) throw new Error('JSON root must be an array of posts');
        POSTS = data;

        statusEl.textContent = `Loaded ${POSTS.length} posts. Pick one to begin.`;
        hydrateSearchPlaceholder();

        // Open by ?id= if present
        const url = new URL(window.location.href);
        const idParam = url.searchParams.get('id');
        if (idParam) {
          const idx = findIndexById(idParam);
          if (idx !== -1) { goToIndex(idx); return; }
        }
        if (POSTS.length) goToIndex(0);
      } catch (err) {
        console.error('Failed to load data:', err);
        statusEl.textContent = 'Failed to load omori_posts.json. Ensure it is accessible and valid.';
        setDiscPlaceholder(postDiscEl, 'Dataset could not be loaded');
        postTitleEl.textContent = 'Dataset could not be loaded';
        postMetaEl.innerHTML = '';
      }
    }

    function hydrateSearchPlaceholder() {
      if (!POSTS.length) return;
      const p0 = POSTS[0];
      const ex = p0 ? (p0.id || p0.title || 'post-id') : 'post-id';
      searchInput.placeholder = `Search by title, id, or authorâ€¦ e.g. ${ex}`;
    }

    // Boot
    loadData();
  </script>
</body>
</html>
